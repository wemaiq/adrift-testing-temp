<!DOCTYPE html>
<html lang="en"><head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-H3F6SJKBRK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-H3F6SJKBRK');
</script>
  
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Figtree:ital,wght@0,300..900;1,300..900&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Dongle&display=swap" rel="stylesheet">


<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<!-- SEO + AEO Metadata -->
<title>Adrift — A Quiet Place to Share or Read Anonymous Doubts</title>
<meta name="description" content="Adrift is a quiet digital space where people can anonymously share doubts as paper boats, or read others’ doubts drifting in and out of view.">
<meta name="keywords" content="anonymous doubts, share doubts, read doubts, paper boats, quiet space, uncertainty">

<!-- Open Graph -->
<meta property="og:title" content="Adrift — A Quiet Place to Share or Read Anonymous Doubts">
<meta property="og:description" content="A quiet place to anonymously share doubts as paper boats, or read others’ drifting doubts.">
<meta property="og:url" content="https://adrift.site/">
<meta property="og:type" content="website">
<meta property="og:image" content="https://adrift.site/Opengraph-adrift.jpg">
<meta property="og:image:secure_url" content="https://adrift.site/Opengraph-adrift.jpg">
<meta property="og:image:type" content="image/jpeg">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Adrift — A Quiet Place to Share or Read Anonymous Doubts">
<meta name="twitter:description" content="Adrift is a quiet space where doubts drift as paper boats — shared anonymously, read quietly.">
<meta name="twitter:image" content="https://adrift.site/Opengraph-adrift.jpg">

<!-- Schema.org (Structured Data for AEO) -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "name": "Adrift",
  "url": "https://adrift.site/",
  "description": "Adrift is a quiet place where people anonymously submit doubts that become paper boats, or read anonymous doubts from others as they drift in and out of view.",
  "potentialAction": {
    "@type": "SearchAction",
    "target": "https://adrift.site/?q={search_term_string}",
    "query-input": "required name=search_term_string"
  }
}
</script>


<!-- Favicons -->
<link rel="icon" type="image/svg+xml" sizes="16x16" href="favicon-adrift-16x16.svg">
<link rel="icon" type="image/svg+xml" sizes="32x32" href="favicon-adrift-32x32.svg">
<link rel="shortcut icon" href="favicon-adrift-32x32.svg" type="image/svg+xml">

<style>
  :root{
    --paper-edge: #e8e3da;
    --paper-face: #e8e3da;
    --bloom-a: rgba(220, 211, 199, 0.40);
    --bloom-b: rgba(220, 211, 199, 0.40);
  }

  html, body { height:100%; }
  body { margin:0; background:#000; overflow:hidden; font-family: ui-sans-serif, system-ui; color:#ececed; }
  canvas { display:block; width:100%; height:100%; }

  /* Intro overlay */
  #intro-overlay {
    position: fixed;
    inset: 0;
    background: #000;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    opacity: 1;
    transition: opacity 1s ease-out;
    pointer-events: all;
  }
  
  #intro-overlay.fade-out {
    opacity: 0;
    pointer-events: none;
  }
  
  .intro-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    max-width: 520px;
    gap: 20px;
  }

  #doubt-counter {
    font-family: "Figtree", ui-sans-serif, system-ui, sans-serif;
    font-size: 11px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: rgba(236, 236, 237, 0.6);
    opacity: 0;
    transform: translateY(8px);
    animation: introContentReveal 1.2s ease forwards;
    font-weight: 400;
  }

  #intro-text {
    font-family: "Figtree", ui-sans-serif, system-ui, sans-serif;
    font-size: 19.2px;
    line-height: 1.8;
    color: rgba(236, 236, 237, 0.85);
    max-width: 520px;
    margin: 0;
    opacity: 0;
    transform: translateY(8px);
    animation: introContentReveal 1.2s ease forwards;
    font-weight: 300;
    letter-spacing: 0.02em;
  }

  #intro-text.fade-out-text {
    animation: fadeOutText 1.5s ease-out forwards;
  }

  #intro-overlay .cta-btn {
    position: static;
    bottom: auto;
    z-index: auto;
  }

  .intro-enter-btn {
    opacity: 0;
    transform: translateY(16px);
    animation: introButtonRise 0.9s ease forwards;
    animation-delay: 1s;
  }

  @keyframes introContentReveal {
    from {
      opacity: 0;
      transform: translateY(14px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes fadeOutText {
    to {
      opacity: 0;
    }
  }

  @keyframes introButtonRise {
    from {
      opacity: 0;
      transform: translateY(18px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Initially hide main content */
  .main-content {
    opacity: 0;
    transition: opacity 1.5s ease-in;
  }
  
  .main-content.visible {
    opacity: 1;
  }

  /* Layering: rain over boats (click-through), boats under notes */
  #rain  { position:fixed; inset:0; z-index:2; pointer-events:none; }
  #canvas{ position:fixed; inset:0; z-index:1; }

  header{ font-weight:400; position:fixed; top:18px; left:50%; transform:translateX(-50%); letter-spacing:0.25em; font-size:20px; font-family:"Dongle", ui-sans-serif, system-ui, sans-serif;text-transform:uppercase; text-align:center; user-select:none; z-index:5; }
  .hint{ font-weight:400; position:fixed; left:20px; bottom:16px; color:#9aa0a8; font-size:12px; opacity:.7; user-select:none; background: rgba(255,255,255,.03); letter-spacing: 0.05em; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,.06); backdrop-filter: blur(3px); z-index:5; }

  /* View toggle */
  .view-toggle {
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 4px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,.18);
    background: rgba(255,255,255,.04);
    backdrop-filter: blur(3px);
    z-index: 5;
  }

  .view-toggle__option {
    position: relative;
    border: 0;
    border-radius: 999px;
    background: transparent;
    color: rgba(236,236,237,.68);
    font-family: "Figtree", ui-sans-serif, system-ui, sans-serif;
    font-size: 10px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    padding: 8px 18px;
    line-height: 1;
    cursor: pointer;
    transition: color .25s ease, background .25s ease, box-shadow .25s ease;
  }

  .view-toggle__option:focus-visible {
    outline: 2px solid rgba(255, 200, 100, 0.35);
    outline-offset: 2px;
  }

  .view-toggle__option.is-active {
    color: #ececed;
    background: rgba(255,255,255,.12);
    box-shadow: 0 10px 24px rgba(0,0,0,.3);
  }

  .view-toggle__option.is-active::after {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: inherit;
    border: 1px solid rgba(255,255,255,.22);
    pointer-events: none;
  }

  .is-hidden {
    display: none !important;
  }

  /* Support column */
  .support-column {
    position: fixed;
    top: 136px;
    right: 24px;
    width: min(320px, calc(100vw - 48px));
    max-height: calc(100vh - 188px);
    display: flex;
    flex-direction: column;
    gap: 14px;
    padding: 18px;
    border-radius: 22px;
    background: rgba(14, 18, 28, 0.72);
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 18px 38px rgba(0,0,0,0.45);
    backdrop-filter: blur(14px);
    color: rgba(236,236,237,0.86);
    z-index: 5;
    box-sizing: border-box;
  }

  .support-column[hidden] {
    display: none !important;
  }

  .support-column__header {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .support-column__title {
    margin: 0;
    font-family: "Figtree", ui-sans-serif, system-ui, sans-serif;
    font-size: 12px;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    color: rgba(236,236,237,0.62);
  }

  .support-column__subtitle {
    margin: 0;
    font-size: 13px;
    line-height: 1.6;
    color: rgba(236,236,237,0.72);
    letter-spacing: 0.01em;
  }

  .support-column__list {
    margin: 0;
    padding: 0;
    list-style: none;
    display: flex;
    flex-direction: column;
    gap: 12px;
    overflow-y: auto;
    padding-right: 2px;
    scrollbar-width: thin;
  }

  .support-column__list::-webkit-scrollbar {
    width: 6px;
  }

  .support-column__list::-webkit-scrollbar-track {
    background: transparent;
  }

  .support-column__list::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,0.16);
    border-radius: 999px;
  }

  .support-column__item {
    margin: 0;
  }

  .support-item {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
    padding: 15px 16px 14px;
    border-radius: 18px;
    border: 1px solid rgba(255,255,255,0.08);
    background: rgba(255,255,255,0.05);
    color: rgba(236,236,237,0.9);
    font-family: "Figtree", ui-sans-serif, system-ui, sans-serif;
    font-size: 15px;
    line-height: 1.6;
    text-align: left;
    cursor: pointer;
    transition: border-color .22s ease, background .22s ease, transform .22s ease;
  }

  .support-item:hover,
  .support-item:focus-visible {
    border-color: rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    transform: translateY(-1px);
  }

  .support-item:focus-visible {
    outline: 2px solid rgba(255, 200, 120, 0.45);
    outline-offset: 2px;
  }

  .support-item__text {
    display: block;
    width: 100%;
    color: inherit;
    word-break: break-word;
  }

  .support-item__meta {
    display: block;
    font-size: 11px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: rgba(236,236,237,0.55);
  }

  .support-column__empty {
    font-size: 13px;
    color: rgba(236,236,237,0.65);
    line-height: 1.6;
  }

  @media (max-width: 600px) {
    .view-toggle {
      top: 72px;
      padding: 3px;
    }

    .view-toggle__option {
      padding: 6px 14px;
      font-size: 11px;
      letter-spacing: 0.05em;
    }
  }

  @media (max-width: 640px) {
    .support-column {
      top: 118px;
      right: 16px;
      left: 16px;
      width: auto;
      max-height: calc(100vh - 210px);
      padding: 16px;
      gap: 12px;
    }

    .support-column__title {
      font-size: 11px;
      letter-spacing: 0.14em;
    }

    .support-column__subtitle {
      font-size: 12px;
    }

    .support-item {
      font-size: 14px;
      padding: 14px;
    }
  }

  /* Sound toggle */
  .sound-toggle{
    position:fixed; right:20px; bottom:16px; z-index:5;
    background: rgba(255,255,255,.03);
    color:#9aa0a8; font-size:12px; line-height:1;
    padding:8px 10px; border-radius:10px;
    border:1px solid rgba(255,255,255,.06);
    backdrop-filter: blur(3px);
    cursor:pointer; user-select:none;
    letter-spacing: 0.05em;
  }
  .sound-toggle.active{ color:#ececed; border-color: rgba(255,255,255,.12); }
  .sound-toggle:focus-visible{ outline:2px solid rgba(255, 200, 100, 0.25); outline-offset:2px; }

  /* Center-bottom CTA (kept) */
  .cta-btn{
    padding:28px 36px; border-radius:9999px; font-size:13px; line-height:1; color:#fff;
    letter-spacing: 0.05em;
    border:1px solid rgba(255,255,255,.28);
    background: rgba(255,255,255,.04);
    backdrop-filter: blur(3px);
    transition: box-shadow .25s ease, transform .2s ease, border-color .25s ease, background .25s ease;
    cursor:pointer; user-select:none;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
    white-space: nowrap;
  }

  .cta-btn--floating {
    position:fixed; left:50%; transform:translateX(-50%); bottom:16px; z-index:5;
  }
  .cta-btn:hover{ box-shadow: 0 0 36px 12px rgba(255, 219, 90, 0.174), 0 0 8px 2px rgba(255,255,255,.25); border-color: rgba(255,255,255,.5); }
  .cta-btn:focus-visible{ outline:2px solid rgba(255, 200, 100, 0.35); outline-offset:3px; }

  /* Hidden media */
  #boatVideo, #bgAudio { position: fixed; left:-9999px; top:-9999px; width:1px; height:1px; opacity:0; pointer-events:none; }

  /* ===========================================================
     Unfolding NOTE (used for both boat view + composer)
     =========================================================== */
  .note-overlay { position: fixed; inset:0; z-index:6; pointer-events:none; }
  .overlay-close { position:fixed; inset:0; background: transparent; pointer-events:auto; }

  .note{
    position:absolute;
    width: min(350px, 90vw); 
    height: min(350px, 90vw);
    transform-style: preserve-3d; perspective: 800px;
    pointer-events:auto;
    filter: drop-shadow(0 12px 40px rgba(0,0,0,.55));
    transition: transform .35s ease, opacity .25s ease;
    cursor: grab;
    user-select: none; touch-action: none;
    will-change: left, top, opacity, transform;
    background: transparent;
  }
  .note.dragging{ cursor: grabbing; }
  .note.closing{ opacity:0; transform: scale(.98) translateZ(0); pointer-events:none; }

  /* FIXED: Circle close button for mobile */
  .note-close{
    position:absolute; top:10px; right:10px;
    width:28px; height:28px;
    border-radius:50%;
    aspect-ratio: 1 / 1;
    display:flex;
    align-items:center;
    justify-content:center;
    background: rgba(12,14,18,.65);
    color:#fff; font-size:16px; line-height:1;
    border:1px solid rgba(255,255,255,.18);
    box-shadow:none;
    cursor:pointer;
    opacity:0; 
    pointer-events:none;
    transition: opacity .25s ease, transform .20s ease, background .2s ease, border-color .2s ease;
    z-index:3;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    padding: 0;
    box-sizing: border-box;
    overflow: hidden;
    text-align: center;
    transform: scale(.92) translateZ(0);
    -webkit-transform: scale(.92) translateZ(0);
  }
  .note.unfold .note-close{
    opacity:1; transform: scale(1) translateZ(0);
    transition-delay: 1.25s, 1.25s, 0s, 0s;
    pointer-events:auto;
  }
  .note-close:hover{ transform: scale(1.06) translateZ(0); background: rgba(12,14,18,.78); border-color: rgba(255,255,255,.28); }
  .note-close:active{ transform: scale(.98) translateZ(0); }
  .note-close:focus-visible{ outline:2px solid rgba(255, 180, 60, 0.5); outline-offset:2px; }

  .note-stage, .note-frame {
    position:absolute; left:50%; top:50%; transform:translate(-50%, -50%);
    width:100%; height:100%;
  }
  .note-frame{
    opacity:0;
    box-shadow: 0 0 40px rgba(0,0,0,0.06);
    animation: note-show 0.5s 1s ease forwards;
  }

  .note-box{
    position:absolute;
    width:calc(50% - 25px); height:calc(50% - 25px);
    background: var(--paper-face);
    border: 25px solid var(--paper-edge);
    box-shadow: 0 0 40px rgba(0,0,0,0.07);
    overflow:hidden; border-radius:4px;
  }
  .note-box .note-in{
    position:absolute; width:100px; height:100px; border-radius:50%;
    background: transparent !important;
    animation: note-grow 0.5s 3s cubic-bezier(0.66,-0.30,0.66,1) forwards;
  }
  .note-box .one{ left:100px; bottom:-50px; }
  .note-box .two{ left:-50px;  bottom:-50px; }
  .note-box .thr{ left:100px; bottom:100px; }
  .note-box .fou{ left:-50px;  bottom:100px; }

  .note-box:nth-child(1){ border-right:none; border-bottom:none; border-radius: 5px 0 0 0; animation: note-clr 0.5s 0.5s ease forwards; }
  .note-box:nth-child(2){ left:50%; border-left:none; border-bottom:none; border-radius: 0 5px 0 0; transform-origin: 0 0; transform: rotateY(180deg); animation: note-fold 0.5s 0.5s ease forwards; }
  .note-box:nth-child(3){ top:50%; opacity:0; border-top:none; border-right:none; border-radius: 0 0 0 5px; transform: rotateX(180deg); transform-origin: 0 0; animation: note-fold2 0.5s 1s ease forwards; }
  .note-box:nth-child(4){ top:50%; left:50%; opacity:0; border-top:none; border-left:none; border-radius: 0 0 5px 0; transform: rotateX(180deg); transform-origin: 0 0; animation: note-fold2 0.5s 1s ease forwards; }

  .note-content{
    position:absolute; inset:22px 24px;
    display:flex; flex-direction:column; justify-content:flex-start;
    color:#0e1520; opacity:0; transform: translateY(4px);
    transition: opacity .45s ease 1.2s, transform .45s ease 1.2s;
    font-synthesis-weight:none;
    padding: 0;
    background: transparent;
  }
  .note.unfold .note-content{ opacity:1; transform: translateY(0); }

  .note-title{ font-size:11px; letter-spacing:.12em; text-transform:uppercase; color:#4c5562; margin-bottom:10px; }
  .note-text{ font-size:20px; line-height:1.55; color:#10151c; }
  .note-meta{ margin-top:14px; font-size:12px; color:#5a6472; }

  @keyframes note-clr { 0%, 100% { background: var(--paper-face); } }
  @keyframes note-fold { 0%, 99.99% { background: var(--paper-face); } 100% { background: var(--paper-face); transform: rotateY(360deg); } }
  @keyframes note-fold2 { 0%{opacity:1;background:var(--paper-face);} 25%{opacity:1} 40%{opacity:1} 100%{opacity:1;background:var(--paper-face);transform: rotateX(0deg);} }
  @keyframes note-show { to { opacity:1; } }

  /* Composer form bits (used inside .note-content) */
  .compose-field{ width:100%; min-height:110px; resize:vertical; box-sizing:border-box; border-radius:8px; border:1px solid rgba(0,0,0,.1); padding:10px 12px; font: 16px/1.5 ui-sans-serif, system-ui; color:#0e1520; background:#fff; }
  .compose-field:focus {
    outline: none;
    border-color: rgba(7, 7, 7, 0.4);
    box-shadow: 0 0 0 1px rgba(255, 180, 60, 0.15);
  }
  .compose-foot{ display:flex; justify-content:space-between; align-items:center; margin-top:10px; font-size:12px; color:#4c5562; }
 .compose-disclaimer {
  font-size: 11px;
  color: rgba(16,21,28,0.55);
  text-align: center;
  margin-top: 14px;
}
  .pill-btn{ padding:12px 18px; border-radius:999px; border:1px solid rgba(0,0,0,.12); background:#0f172a; color:#fff; cursor:pointer; }
  .pill-btn:focus-visible {
    outline: 2px solid rgba(255, 180, 60, 0.5);
    outline-offset: 2px;
  }

  .note .compose-field { touch-action: auto; user-select: text; }
  .note .compose-foot button { touch-action: auto; }

/* --- Added: font smoothing, Figtree font, and ripple effect --- */
html { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-rendering: optimizeLegibility; }

.figtree-adrift {
  font-family: "Figtree", ui-sans-serif, system-ui, sans-serif;
  font-optical-sizing: auto;
  font-weight: 600;
  font-style: normal;
}

.dongle-regular {
  font-family: "Dongle", sans-serif;
  font-weight: 400;
  font-style: normal;
}


.ripple > * {
  display: inline-block;
  text-shadow: 0 0 0 #fff;
  color: transparent;
}

@keyframes rippleEffect {
  40% {
    opacity: .35;
  }
  50% {
    transform: translate3d(.5em, 0, 0) scale(1.1);
    text-shadow: 0 0 20px #fff;
  }
  75% {
    transform: translate3d(0, 0, 0) scale(1);
    text-shadow: 0 0 0 #fff;
    opacity: 1;
  }
}
/* --- end added --- */

/* --- Added: ensure header uses Figtree --- */
header.ripple span.figtree-adrift {
  font-family: "Figtree", ui-sans-serif, system-ui, sans-serif;
  font-weight: 700;
}
/* --- end added --- */

/* === ADDED: loading dots for Enter button === */
.loading-dots { display:inline-flex; gap:.25em; margin-left:.4em; vertical-align:baseline; }
.loading-dots span { width:.35em; height:.35em; border-radius:50%; background: currentColor; opacity:.2; animation: dotBlink 1s infinite; }
.loading-dots span:nth-child(2){ animation-delay:.15s; }
.loading-dots span:nth-child(3){ animation-delay:.30s; }
@keyframes dotBlink {
  0%, 20% { opacity:.2; transform: translateY(0); }
  50%     { opacity:1;  transform: translateY(-1px); }
  100%    { opacity:.2; transform: translateY(0); }
}
/* === end loading dots === */

/* Mobile responsive styles */
@media (max-width: 640px) {
  .intro-content {
    max-width: 90vw;
    gap: 16px;
  }

  #doubt-counter {
    font-size: 12px;
    letter-spacing: 0.1em;
  }

  #intro-text {
    font-size: 16.8px;
    max-width: 90vw;
  }

  #intro-overlay .cta-btn {
    width: auto;
    padding: 20px 28px;
    align-self: center;
  }
  
  .note-content {
  inset: 21px 18px 16px 18px; /* Top padding increased to align with repositioned close button */
}
  
  .note-text {
    font-size: 18px; /* Smaller text */
  }
  
  .note-title {
    font-size: 10px;
  }
  
  .note-meta {
    font-size: 11px;
  }
  
  .cta-btn {
    padding: 20px 28px; /* Slightly smaller on mobile */
    font-size: 12px;
  }

  .cta-btn--floating {
    bottom: 70px;
  }
  
  header {
    font-size: 18px; /* Slightly smaller header on mobile */
  }
  
  /* Larger close button on mobile for better touch targets */
 .note-close {
  top: 6px; /* changed from 10px to 15px */
  width: 32px;
  height: 32px;
  font-size: 18px;
  min-width: 32px;
  min-height: 32px;
  max-width: 32px;
  max-height: 32px;
  /* Add these for better centering */
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
  font-family: -apple-system, BlinkMacSystemFont, sans-serif; /* More consistent font */
  padding-bottom: 1px; /* Fine-tune vertical centering if needed */
  }
}


/* Landscape mobile - spread out bottom elements */
@media (max-height: 500px) and (orientation: landscape) {
  .hint { left: 10px; bottom: 10px;}
  .sound-toggle { right: 10px; bottom: 10px; }
  .cta-btn { padding: 16px 24px; }
  .cta-btn--floating { bottom: 16px; }
  header { top: 10px; }
  .view-toggle { top: 64px; }
}

/* For high-DPI displays (retina) */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
  .note-close {
    /* Force antialiasing for smoother circles */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    backface-visibility: hidden;
    transform-style: flat;
  }
}
</style>
</head>
<body class="figtree-adrift">
  <!-- Intro overlay -->
 <div id="intro-overlay">
    <div class="intro-content">
      <div id="doubt-counter" aria-live="polite" data-start-value="0">0 boats released</div>
      <p id="intro-text">Adrift is a quiet space where doubts become paper boats and drift together across a shared sea.</p>
      <button id="enterBtn" class="cta-btn intro-enter-btn" type="button">Enter</button>
    </div>
  </div>

  <!-- Main content wrapper -->
  <div class="main-content">
    <header class="ripple"><span><span>a</span><span>d</span><span>r</span><span>i</span><span>f</span><span>t</span></span></header>
    <div class="view-toggle" role="group" aria-label="Choose between doubts and affirmations">
      <button type="button" class="view-toggle__option is-active" data-view="doubts" aria-pressed="true">Doubt</button>
      <button type="button" class="view-toggle__option" data-view="affirmations" aria-pressed="false">Care</button>
    </div>

    <aside class="support-column" aria-label="Community care" hidden>
      <div class="support-column__header">
        <h2 class="support-column__title">Care from the drift</h2>
        <p class="support-column__subtitle">Tap a care note to unfold support.</p>
      </div>
      <ul class="support-column__list" id="supportList"></ul>
    </aside>

    <!-- media -->
    <video id="boatVideo" src="boat.mp4" loop="" muted="" playsinline="" preload="auto"></video>
    <audio id="bgAudio" src="sound.mp3" loop="" preload="auto"></audio>

    <!-- layers -->
    <canvas id="rain" aria-hidden="true"></canvas>
    <canvas id="canvas"></canvas>

    <div class="hint">Click boat to unfold</div>
    <button id="soundToggle" class="sound-toggle" aria-pressed="false" aria-label="Enable sound">Sound: Off</button>
    <button id="releaseBtn" class="cta-btn cta-btn--floating" aria-label="Release your doubt">Release your doubt</button>
  </div>

  <script src="./rain.js" defer=""></script>

<script>
  /* =====================
     Intro sequence
     ===================== */
  const introOverlay = document.getElementById('intro-overlay');
  const introText = document.getElementById('intro-text');
  const mainContent = document.querySelector('.main-content');
  const enterBtn = document.getElementById('enterBtn');
  const doubtCounter = document.getElementById('doubt-counter');
  const viewToggle = document.querySelector('.view-toggle');
  const viewToggleButtons = viewToggle ? viewToggle.querySelectorAll('.view-toggle__option') : [];
  const supportColumn = document.querySelector('.support-column');
  const supportList = document.getElementById('supportList');
  const hintEl = document.querySelector('.hint');

  let SUPPORT_NOTES = [];
  let ACTIVE_SUPPORT_NOTES = [];
  let SHUFFLED_SUPPORT_NOTES = [];
  let USED_SUPPORT_IDS = new Set();
  let supportFetchPromise = null;

  function normalizeSupportItem(raw = {}, fallbackRow = {}, index = 0) {
    if (!raw) return null;

    const boolKeys = ['active', 'enabled', 'is_active', 'isActive', 'published', 'visible', 'show', 'approved'];
    let hasBooleanGate = false;
    let passesGate = false;

    for (const key of boolKeys) {
      if (Object.prototype.hasOwnProperty.call(raw, key)) {
        const value = raw[key];
        if (typeof value === 'boolean') {
          hasBooleanGate = true;
          if (value) passesGate = true;
        } else if (typeof value === 'string') {
          const normalized = value.trim().toLowerCase();
          if (normalized === 'true') {
            hasBooleanGate = true;
            passesGate = true;
          } else if (normalized === 'false') {
            hasBooleanGate = true;
          }
        }
      }
    }

    if (hasBooleanGate && !passesGate) return null;

    const text = String(raw.text ?? raw.message ?? raw.body ?? raw.note ?? '').trim();
    if (!text) return null;

    const attribution = raw.attribution ?? raw.byline ?? raw.author ?? raw.source ?? '';
    const idCandidate = raw.id ?? raw.uuid ?? raw.slug ?? `${fallbackRow?.id ?? 'support'}-${index}`;

    let date = '';
    const dateValue = raw.date ?? raw.display_date ?? raw.created_at ?? fallbackRow?.created_at ?? '';
    if (typeof dateValue === 'string' && dateValue.trim()) {
      date = dateValue.slice(0, 10);
    } else if (dateValue instanceof Date) {
      date = dateValue.toISOString().slice(0, 10);
    } else if (typeof dateValue === 'number') {
      const parsed = new Date(dateValue);
      if (!Number.isNaN(parsed.getTime())) {
        date = parsed.toISOString().slice(0, 10);
      }
    }

    return {
      id: String(idCandidate),
      text,
      attribution: attribution ? String(attribution) : '',
      date,
      active: true
    };
  }

  function setSupportNotes(items = []) {
    const normalized = [];
    const seenIds = new Set();
    const seenTexts = new Set();

    for (const item of items) {
      if (!item || !item.text) continue;
      const idKey = item.id ? String(item.id) : '';
      const textKey = item.text.replace(/\s+/g, ' ').trim().toLowerCase();

      if (idKey && seenIds.has(idKey)) continue;
      if (!idKey && textKey && seenTexts.has(textKey)) continue;

      if (idKey) {
        seenIds.add(idKey);
      } else if (textKey) {
        seenTexts.add(textKey);
      }

      normalized.push({ ...item, id: idKey || `support-${normalized.length + 1}` });
    }

    SUPPORT_NOTES = normalized;
    ACTIVE_SUPPORT_NOTES = normalized.filter(item => item && item.active !== false);
    initializeSupportPool();
    renderSupportColumn();
  }

  function initializeSupportPool() {
    if (!ACTIVE_SUPPORT_NOTES.length) {
      SHUFFLED_SUPPORT_NOTES = [];
      USED_SUPPORT_IDS.clear();
      return;
    }

    let shuffled = shuffleArray(ACTIVE_SUPPORT_NOTES);
    const randomStart = Math.floor(Math.random() * shuffled.length);
    SHUFFLED_SUPPORT_NOTES = [...shuffled.slice(randomStart), ...shuffled.slice(0, randomStart)];
    USED_SUPPORT_IDS.clear();
  }

  function pickRandomCareNote() {
    if (!ACTIVE_SUPPORT_NOTES.length) {
      return {
        id: 'care-placeholder',
        text: 'Care notes are on their way.',
        date: new Date().toISOString().slice(0, 10),
        attribution: ''
      };
    }

    if (!SHUFFLED_SUPPORT_NOTES.length || USED_SUPPORT_IDS.size >= SHUFFLED_SUPPORT_NOTES.length) {
      initializeSupportPool();
    }

    let selected = null;
    for (const item of SHUFFLED_SUPPORT_NOTES) {
      if (!USED_SUPPORT_IDS.has(item.id)) {
        selected = item;
        break;
      }
    }

    if (!selected) {
      selected = SHUFFLED_SUPPORT_NOTES[0];
    }

    USED_SUPPORT_IDS.add(selected.id);
    return { ...selected };
  }

  let currentView = 'doubts';

  function escapeHtml(str = '') {
    return String(str).replace(/[&<>"']/g, (char) => {
      switch (char) {
        case '&': return '&amp;';
        case '<': return '&lt;';
        case '>': return '&gt;';
        case '"': return '&quot;';
        case "'": return '&#39;';
        default: return char;
      }
    });
  }

  function normalizeTextPreview(text, maxLength = 120) {
    const clean = String(text || '').replace(/\s+/g, ' ').trim();
    if (clean.length <= maxLength) return clean;
    return clean.slice(0, Math.max(0, maxLength - 1)).trimEnd() + '…';
  }

  function renderSupportColumn() {
    if (!supportList) return;
    supportList.textContent = '';

    const activeItems = ACTIVE_SUPPORT_NOTES;

    if (!activeItems.length) {
      const emptyItem = document.createElement('li');
      emptyItem.className = 'support-column__empty';
      emptyItem.textContent = 'Care notes are on their way.';
      supportList.appendChild(emptyItem);
      return;
    }

    activeItems.forEach((item) => {
      const li = document.createElement('li');
      li.className = 'support-column__item';

      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'support-item';
      button.dataset.careId = item.id;
      button.addEventListener('click', () => openCareNote(item));

      const textSpan = document.createElement('span');
      textSpan.className = 'support-item__text';
      textSpan.textContent = item.text;
      button.appendChild(textSpan);

      const metaParts = [];
      if (item.date) {
        const parsed = new Date(item.date + 'T00:00:00');
        if (!Number.isNaN(parsed.getTime())) {
          metaParts.push(parsed.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' }));
        }
      }
      if (item.attribution) {
        metaParts.push(item.attribution);
      }
      if (metaParts.length) {
        const meta = document.createElement('span');
        meta.className = 'support-item__meta';
        meta.textContent = metaParts.join(' • ');
        button.appendChild(meta);
      }

      button.setAttribute('aria-label', `Open care note: ${normalizeTextPreview(item.text, 140)}`);
      li.appendChild(button);
      supportList.appendChild(li);
    });
  }

  function openCareNote(item) {
    const metaParts = [];
    if (item.date) {
      const parsed = new Date(item.date + 'T00:00:00');
      if (!Number.isNaN(parsed.getTime())) {
        metaParts.push(parsed.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' }));
      }
    }
    if (item.attribution) {
      metaParts.push(item.attribution);
    }

    const metaHTML = metaParts.length ? `<div class="note-meta">${escapeHtml(metaParts.join(' • '))}</div>` : '';
    const bodyHTML = `<div class="note-text">${escapeHtml(item.text).replace(/\n/g, '<br>')}</div>`;

    createNote({
      x: innerWidth / 2,
      y: innerHeight / 2,
      title: 'Community Care',
      bodyHTML,
      metaHTML,
      boat: null,
      startScale: 0.72
    });
  }

  initializeSupportPool();
  renderSupportColumn();

  function updateToggleState() {
    if (!viewToggleButtons.length) return;
    viewToggleButtons.forEach((btn) => {
      const isActive = (btn.dataset.view === currentView);
      btn.classList.toggle('is-active', isActive);
      btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
  }

  function setView(view) {
    const normalized = view === 'affirmations' ? 'affirmations' : 'doubts';
    if (normalized === currentView) return;
    currentView = normalized;
    updateBoatVideoSource(normalized);
    updateToggleState();
    reseedBoatsForCurrentView();
    applyViewState();
  }

  if (viewToggleButtons.length) {
    viewToggleButtons.forEach((button) => {
      button.addEventListener('click', () => {
        const targetView = button.dataset.view || 'doubts';
        if (targetView === currentView) return;
        setView(targetView);
      });
    });
  }

  function getCurrentVariant() {
    return currentView === 'affirmations' ? 'cheer' : 'doubt';
  }

  function reseedBoatsForCurrentView({ highlight = false } = {}) {
    if (!boats || !boats.length) return;
    const variant = getCurrentVariant();
    const now = performance.now();

    boats.forEach((boat) => {
      boat.variant = variant;
      boat.reset(true);
      if (highlight) {
        boat.highlightUntil = now + 4000;
      }
    });
  }

  /* === ADDED: preload helpers and loading UI === */
  function preloadVideo(videoEl){
    return new Promise((resolve) => {
      if (!videoEl) return resolve();
      const done = () => resolve();
      if (videoEl.readyState >= 2) return resolve(); // HAVE_CURRENT_DATA
      videoEl.addEventListener('canplay', done, { once:true });
      try {
        videoEl.load();
        // muted video can play without gesture; prime a frame then pause
        videoEl.play().then(()=>{ videoEl.pause(); }).catch(()=>{ /* ignore */ });
      } catch(_) {}
    });
  }

  function preloadAudio(audioEl){
    return new Promise((resolve) => {
      if (!audioEl) return resolve();
      const done = () => resolve();
      if (audioEl.readyState >= 2) return resolve();
      audioEl.addEventListener('canplaythrough', done, { once:true });
      try { audioEl.load(); } catch(_) {}
      // do not play; just buffer
    });
  }

  function preloadFonts(){
    if (document.fonts && document.fonts.ready) return document.fonts.ready.catch(()=>{});
    return Promise.resolve();
  }

  function preloadScriptAlreadyInPage(src){
    const tag = [...document.scripts].find(s => (s.src||'').includes(src));
    if (!tag) return Promise.resolve();
    if (tag.dataset.loaded === '1' || tag.dataset.error === '1') return Promise.resolve();
    return new Promise((resolve)=> {
      tag.addEventListener('load', ()=>{ tag.dataset.loaded='1'; resolve(); }, { once:true });
      tag.addEventListener('error',()=>{ tag.dataset.error='1'; resolve(); }, { once:true });
    });
  }

  async function preloadData(){
    try{
      // Use existing fetchers so first frame has content
      const supportPromise = ensureSupportData(400);
      APPROVED_DOUBTS = await fetchApprovedDoubts(600);
      if (APPROVED_DOUBTS.length === 0) {
        APPROVED_DOUBTS = [{ id:'p1', text:'(waiting for first approved doubt…)', date:new Date().toISOString().slice(0,10) }];
      }
      initializeDoubtPool();
      // Seed boats so render is immediate
      boats = Array.from({length: BOAT_COUNT}, () => new Boat(getCurrentVariant()));
      await supportPromise;
      // Warm up counter silently
      const count = await fetchTotalDoubts().catch(()=>0);
      if (doubtCounter) {
        doubtCounter.style.visibility = 'visible';
        if (count > 0) animateDoubtCounter(doubtCounter, count);
        else doubtCounter.textContent = '0 boats released';
      }
    } catch(err){
      console.error('Data preload failed:', err);
      if (!APPROVED_DOUBTS?.length) {
        APPROVED_DOUBTS = [{ id:'p1', text:'(temporarily unable to load doubts)', date:new Date().toISOString().slice(0,10) }];
        initializeDoubtPool();
        boats = Array.from({length: BOAT_COUNT}, () => new Boat(getCurrentVariant()));
      }
    }
  }

  async function preloadAll(){
    const videoP = preloadVideo(document.getElementById('boatVideo'));
    const audioP = preloadAudio(document.getElementById('bgAudio'));
    const fontsP = preloadFonts();
    const rainP  = preloadScriptAlreadyInPage('rain.js');
    const dataP  = preloadData();

    // Safety cap (4s) so we don’t hang forever waiting on a stubborn canplaythrough
    const cap = new Promise(res => setTimeout(res, 4000));

    await Promise.race([
      Promise.all([videoP, audioP, fontsP, rainP, dataP]),
      cap
    ]);
  }

  function setLoadingUI(isLoading){
    if (!enterBtn) return;
    if (isLoading){
      enterBtn.disabled = true;
      enterBtn.innerHTML = `Loading<span class="loading-dots"><span></span><span></span><span></span></span>`;
    } else {
      enterBtn.disabled = false;
      enterBtn.textContent = 'Enter';
    }
  }
  /* === end preload helpers === */

  function revealMainContent() {
    if (!introOverlay || introOverlay.classList.contains('fade-out')) return;
    if (introText) {
      introText.classList.add('fade-out-text');
    }
    introOverlay.classList.add('fade-out');
    if (mainContent) {
      mainContent.classList.add('visible');
    }
    setTimeout(() => {
      introOverlay.remove();
    }, 1200);
  }

  if (enterBtn) {
    enterBtn.addEventListener('click', async () => {
      if (enterBtn.disabled) return;
      setLoadingUI(true);
      try {
        await preloadAll();   // preload video, audio (buffer only), fonts, rain.js (best effort), data + seed boats
      } finally {
        setLoadingUI(false);
        revealMainContent();  // only after preload finishes (or the 7s cap)
      }
    });
  }

  /* =====================
     Supabase config (READ)
     ===================== */
  const SUPABASE_URL  = 'https://lrjpntpvcgzjhowrlmit.supabase.co';
  const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxyanBudHB2Y2d6amhvd3JsbWl0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY0OTk4ODcsImV4cCI6MjA3MjA3NTg4N30.sDdezusu8bp6lBp6hmU6QnJVIz0Et4VHp5giEpUTa40';

async function fetchApprovedDoubts(limit = 600) {
  // Fetch ALL doubt IDs first
  const idsUrl = `${SUPABASE_URL}/rest/v1/doubts?select=id&approved=is.true`;
  const idsRes = await fetch(idsUrl, {
    headers: {
      apikey: SUPABASE_ANON,
      Authorization: `Bearer ${SUPABASE_ANON}`,
      Accept: 'application/json'
    }
  });
  
  if (!idsRes.ok) {
    throw new Error(`IDs fetch failed (${idsRes.status})`);
  }
  
  const allIds = await idsRes.json();
  console.log('Total doubts available:', allIds.length);
  
  // Randomly shuffle ALL IDs
  const shuffledIds = allIds.sort(() => Math.random() - 0.5);
  
  // Take the first 600 from the shuffled list
  const selectedIds = shuffledIds.slice(0, limit).map(item => item.id);
  
  // Fetch the full data for these specific IDs
  const url = `${SUPABASE_URL}/rest/v1/doubts?select=id,doubt,created_at&id=in.(${selectedIds.join(',')})`;
  const res = await fetch(url, {
    headers: {
      apikey: SUPABASE_ANON,
      Authorization: `Bearer ${SUPABASE_ANON}`,
      Accept: 'application/json'
    }
  });
  
  if (!res.ok) {
    const text = await res.text().catch(()=> '');
    throw new Error(`Supabase fetch failed (${res.status}) ${text}`);
  }
  
  const rows = await res.json();
  console.log('Sample of dates after random selection:', rows.slice(0, 5).map(r => r.created_at));
  
  return rows.map(r => ({
    id: r.id,
    text: r.doubt ?? '',
    date: (r.created_at || new Date().toISOString()).slice(0,10)
  })).filter(d => d.text && d.text.trim().length);
}

async function fetchTotalDoubts() {
  const headers = {
    apikey: SUPABASE_ANON,
    Authorization: `Bearer ${SUPABASE_ANON}`,
    Accept: 'application/json',
    Prefer: 'count=exact'
  };

  const [doubtsResult, supportResult] = await Promise.allSettled([
    fetch(`${SUPABASE_URL}/rest/v1/doubts?select=count&approved=is.true`, { headers }),
    fetch(`${SUPABASE_URL}/rest/v1/doubts?select=count&support=is.true`, { headers })
  ]);

  const parseCount = (result) => {
    if (result.status !== 'fulfilled') return 0;
    const response = result.value;
    if (!response.ok) return 0;
    const total = parseInt(response.headers.get('Content-Range')?.split('/')[1] || '0', 10);
    return Number.isFinite(total) ? total : 0;
  };

  return parseCount(doubtsResult) + parseCount(supportResult);
}

async function fetchSupportNotes(limit = 400) {
  const headers = {
    apikey: SUPABASE_ANON,
    Authorization: `Bearer ${SUPABASE_ANON}`,
    Accept: 'application/json'
  };

  const url = `${SUPABASE_URL}/rest/v1/doubts?select=id,doubt,created_at,support,approved&support=is.true&approved=is.false&order=created_at.desc&limit=${limit}`;

  const res = await fetch(url, { headers });
  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(`Support fetch failed (${res.status}) ${text}`);
  }

  const data = await res.json();
  const rows = Array.isArray(data) ? data : [data];

  return rows
    .map((row, idx) => {
      const supportFlag = typeof row?.support === 'boolean'
        ? row.support
        : String(row?.support ?? '').trim().toLowerCase() === 'true';
      const approvedFlag = typeof row?.approved === 'boolean'
        ? row.approved
        : String(row?.approved ?? '').trim().toLowerCase() === 'true';

      if (!supportFlag || approvedFlag) return null;

      const text = String(row?.doubt ?? '').trim();
      if (!text) return null;

      const createdAt = row?.created_at ? String(row.created_at) : new Date().toISOString();

      return {
        id: row?.id ? String(row.id) : `care-${idx + 1}`,
        text,
        attribution: '',
        date: createdAt.slice(0, 10),
        active: true
      };
    })
    .filter(Boolean)
    .slice(0, limit);
}

async function ensureSupportData(limit = 400) {
  if (supportFetchPromise) return supportFetchPromise;
  supportFetchPromise = (async () => {
    try {
      const notes = await fetchSupportNotes(limit);
      setSupportNotes(notes);
      return notes;
    } catch (err) {
      console.error('Failed to load support notes:', err);
      setSupportNotes([]);
      return [];
    }
  })();
  return supportFetchPromise;
}

function animateDoubtCounter(el, targetValue) {
  if (!el) return;
  const finalValue = Math.max(0, targetValue);
  const startValue = Number(el.dataset.startValue || 0);
  const formatter = new Intl.NumberFormat();
  const formatValue = (value) => `${formatter.format(value)} boats released`;

  if (finalValue <= startValue) {
    el.textContent = formatValue(finalValue);
    el.dataset.startValue = String(finalValue);
    return;
  }

  let startTime;
  const duration = 1600;

  function step(timestamp) {
    if (startTime === undefined) startTime = timestamp;
    const progress = Math.min((timestamp - startTime) / duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3);
    const currentValue = Math.round(startValue + (finalValue - startValue) * eased);
    el.textContent = formatValue(currentValue);
    if (progress < 1) {
      requestAnimationFrame(step);
    } else {
      el.dataset.startValue = String(finalValue);
    }
  }

  requestAnimationFrame(step);
}

  /* ---------- n8n webhook (TEST URL now; switch to /webhook/… for prod) ---------- */
  const N8N_WEBHOOK_URL = 'https://alexmiretski.app.n8n.cloud/webhook/release-doubt';


  async function postDoubtToN8N(text){
    const res = await fetch(N8N_WEBHOOK_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text })
    });
    let data = {};
    try { data = await res.json(); } catch(e) {}
    if (!res.ok || data?.ok === false) {
      const msg = data?.error || `Request failed (${res.status})`;
      throw new Error(msg);
    }
    const d = Array.isArray(data) ? data[0] : data;
    return { id: d.id, created_at: d.created_at, doubt: d.doubt ?? text };
  }

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha:true });
  const boatVideo = document.getElementById('boatVideo');
  const BOAT_VIDEO_SOURCES = {
    doubts: 'boat.mp4',
    affirmations: 'boat-cheers.mp4'
  };
  let activeBoatVideoSrc = boatVideo?.getAttribute('src') || BOAT_VIDEO_SOURCES.doubts;
  const bgAudio = document.getElementById('bgAudio');
  const soundToggle = document.getElementById('soundToggle');
  const releaseBtn = document.getElementById('releaseBtn');

  let W, H;
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    W = innerWidth;  // Keep W and H as CSS pixels
    H = innerHeight;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.scale(dpr, dpr); // Scale the context for crisp rendering
  }
  addEventListener('resize', resize);
  resize();

  function applyViewState() {
    const showingCheers = currentView === 'affirmations';

    if (canvas) {
      canvas.classList.remove('is-hidden');
      canvas.setAttribute('aria-hidden', 'false');
    }

    if (hintEl) {
      hintEl.classList.remove('is-hidden');
      hintEl.textContent = showingCheers ? 'Click boat to unfold a care' : 'Click boat to unfold a doubt';
    }

    if (supportColumn) {
      supportColumn.hidden = true;
      supportColumn.setAttribute('aria-hidden', 'true');
    }

    document.body.classList.toggle('cheers-view', showingCheers);

    if (releaseBtn) {
      const label = showingCheers ? 'Release a care note' : 'Release a doubt';
      releaseBtn.textContent = label;
      releaseBtn.setAttribute('aria-label', label);
    }
  }

  updateToggleState();
  applyViewState();

  /* ====== Media autoplay ====== */
const DEFAULT_VOL = 0.28;
function startAudio(){ bgAudio.volume = DEFAULT_VOL; bgAudio.play().then(()=> updateSoundUI(true)).catch(()=>{}); }
function updateSoundUI(on){ soundToggle.classList.toggle('active', !!on); soundToggle.setAttribute('aria-pressed', on ? 'true' : 'false'); soundToggle.textContent = on ? 'Sound: On' : 'Sound: Off'; }

let videoReady = false;
let videoRestartAttempts = 0;
const MAX_RESTART_ATTEMPTS = 2;
let videoReadyCheckTimeoutId = null;

boatVideo.addEventListener('canplay', () => {
  videoReady = true;
  if (videoReadyCheckTimeoutId) {
    clearTimeout(videoReadyCheckTimeoutId);
    videoReadyCheckTimeoutId = null;
  }
  if (boatVideo.paused) {
    boatVideo.play().catch(() => {});
  }
});

function checkAndRestartVideo() {
  if (!videoReady && videoRestartAttempts < MAX_RESTART_ATTEMPTS) {
    console.warn(`Video not ready after timeout, attempting restart ${videoRestartAttempts + 1}/${MAX_RESTART_ATTEMPTS}`);
    videoRestartAttempts++;

    const currentSrc = boatVideo.src;
    boatVideo.src = '';
    boatVideo.load();
    boatVideo.src = currentSrc + '?t=' + Date.now();

    setTimeout(() => {
      boatVideo.play().catch(() => {
        console.error('Video restart failed');
      });
    }, 500);

    if (videoRestartAttempts < MAX_RESTART_ATTEMPTS) {
      setTimeout(checkAndRestartVideo, 8000);
    }
  }
}

function scheduleVideoReadyCheck() {
  if (videoReadyCheckTimeoutId) {
    clearTimeout(videoReadyCheckTimeoutId);
  }
  videoReadyCheckTimeoutId = setTimeout(() => {
    if (!videoReady) {
      checkAndRestartVideo();
    }
  }, 15000);
}

function updateBoatVideoSource(view) {
  if (!boatVideo) return;
  const desiredSrc = BOAT_VIDEO_SOURCES[view] || BOAT_VIDEO_SOURCES.doubts;
  if (activeBoatVideoSrc === desiredSrc) return;

  activeBoatVideoSrc = desiredSrc;
  videoReady = false;
  videoRestartAttempts = 0;

  if (videoReadyCheckTimeoutId) {
    clearTimeout(videoReadyCheckTimeoutId);
    videoReadyCheckTimeoutId = null;
  }

  boatVideo.pause();
  boatVideo.src = desiredSrc;
  boatVideo.load();
  boatVideo.play().catch(() => {});
  scheduleVideoReadyCheck();
}

// Start immediately, don't wait
boatVideo.play().catch(() => {});
scheduleVideoReadyCheck();

/* ==== CHANGED: don’t start audio when clicking Enter ==== */
let audioStarted = false;
function ensurePlay(e){
  if (audioStarted) return;

  // Ignore interactions on the intro overlay (e.g., clicking "Enter")
  const overlay = document.getElementById('intro-overlay');
  if (overlay && e && overlay.contains(e.target)) {
    return; // do nothing; keep listeners for later interactions
  }

  if (!videoReady) {
    console.log('User interaction - forcing video restart');
    checkAndRestartVideo();
  }
  boatVideo.play().catch(() => {});
  startAudio();
  audioStarted = true;

  // Clean up listeners after first successful start outside the intro
  removeEventListener('pointerdown', ensurePlay);
  removeEventListener('keydown', ensurePlay);
}
addEventListener('pointerdown', ensurePlay);
addEventListener('keydown', ensurePlay);
/* ==== end change ==== */

soundToggle.addEventListener('click', ()=>{ if(bgAudio.paused){ startAudio(); } else { bgAudio.pause(); updateSoundUI(false); } });
document.addEventListener('visibilitychange', ()=>{ if(!document.hidden && !bgAudio.paused){ bgAudio.play().catch(()=>{}); } });

  /* ===== Boats ===== */
  const CROP = {x:0, y:0, w:1, h:1};
  const BOAT_COUNT = window.innerWidth <= 640 ? 8 : 11, BOAT_HEIGHT=140;
  const SPEED_X=0.10, BOB_AMPL=12, BOB_FREQ=0.0016;

  const COLLISION_PAD = 15, PUSH_STRENGTH = 0.02, FRICTION = 0.34;

  // Perspective tuning
  const PERSPECTIVE_MIN_SCALE = 0.70;
  const PERSPECTIVE_MAX_SCALE = 1.35;
  const OPACITY_MIN = 0.35;
  const OPACITY_MAX = 0.95;

  // Holds fetched approved doubts and session tracking
let APPROVED_DOUBTS = [];
let USED_DOUBT_IDS = new Set(); // Track used doubts this session
let SHUFFLED_DOUBTS = []; // Pre-shuffled pool for current session

function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

function initializeDoubtPool() {
  // Double shuffle for more randomness
  let shuffled = shuffleArray(APPROVED_DOUBTS);
  
  // Start from a random position in the shuffled array
  const randomStart = Math.floor(Math.random() * shuffled.length);
  shuffled = [...shuffled.slice(randomStart), ...shuffled.slice(0, randomStart)];
  
  SHUFFLED_DOUBTS = shuffled;
  USED_DOUBT_IDS.clear();
  console.log('Initialized shuffled doubt pool:', SHUFFLED_DOUBTS.length, 'doubts');
}

function pickRandomDoubt() {
  if (APPROVED_DOUBTS.length === 0) {
    // Safe placeholder if fetch returns nothing (or before it completes)
    return { text: "…", date: new Date().toISOString().slice(0,10), id: "placeholder" };
  }

  // If we've used all doubts, reinitialize the pool
  if (USED_DOUBT_IDS.size >= APPROVED_DOUBTS.length) {
    console.log('All doubts used, reshuffling pool');
    initializeDoubtPool();
  }

  // Find the next unused doubt from our shuffled pool
  let selectedDoubt = null;
  for (const doubt of SHUFFLED_DOUBTS) {
    if (!USED_DOUBT_IDS.has(doubt.id)) {
      selectedDoubt = doubt;
      USED_DOUBT_IDS.add(selectedDoubt.id);
      break;
    }
  }

  // Fallback (shouldn't happen with the logic above)
  if (!selectedDoubt) {
    selectedDoubt = SHUFFLED_DOUBTS[0];
    USED_DOUBT_IDS.add(selectedDoubt.id);
  }

  return selectedDoubt;
}


  async function refreshDoubtPool() {
  try {
    const freshDoubts = await fetchApprovedDoubts(600);
    if (freshDoubts.length > 0) {
      const oldLength = APPROVED_DOUBTS.length;
      APPROVED_DOUBTS = freshDoubts;
      
      // Only reinitialize if we got significantly more doubts
      if (freshDoubts.length > oldLength * 1.2) {
        initializeDoubtPool();
        console.log('Refreshed and reshuffled doubt pool:', APPROVED_DOUBTS.length, 'doubts');
      } else {
        console.log('Refreshed doubt pool:', APPROVED_DOUBTS.length, 'doubts');
      }
    }
  } catch (err) {
    console.error('Failed to refresh doubts:', err);
    // Keep using existing doubts if refresh fails
  }
}


  class Boat{
    constructor(variant = 'doubt'){
      this.variant = variant;
      this.reset(true);
    }
    reset(initial = false) {
      // Use canvas dimensions directly (no DPR scaling)
      this.yBase = Math.random() * H * 0.75 + H * 0.1;

      // ENTRY: start fully off-screen to the left (by half-width + 2px)
      const approxW = this._w || (BOAT_HEIGHT * 1.8);
      this.x = initial ? Math.random() * W : -(approxW * 0.5);

      this.phase = Math.random() * Math.PI * 2;
      this.alpha = 0.95;

      const baseEntry = this.variant === 'cheer' ? pickRandomCareNote() : pickRandomDoubt();
      this.entry = { ...baseEntry, type: this.variant };

      this._h = BOAT_HEIGHT;
      this._w = BOAT_HEIGHT * 1.8;
      this.vx = 0;
      this.vy = 0;
      this.highlightUntil = 0;
      this.paused = false;
      this.morphingIn = false;
      this.morphingOut = false;
      this.morphT0 = 0;
    }

    update(t, boats){
      const canMove = !(this.morphingOut);
      if(canMove){ 
        this.x += SPEED_X + this.vx; 
        if(this.x > W + (this._w||160)) this.reset(false); 
      }
      const bob = Math.sin(this.phase + t*BOB_FREQ) * BOB_AMPL; 
      this.y = this.yBase + bob + this.vy;

      const w = this._w || (BOAT_HEIGHT*1.8), h = this._h || BOAT_HEIGHT;
      for(const other of boats){
        if(other === this) continue;
        const ow = other._w || (BOAT_HEIGHT*1.8), oh = other._h || BOAT_HEIGHT;
        const halfW = w*0.5 + COLLISION_PAD, halfH = h*0.5 + COLLISION_PAD;
        const otherHalfW = ow*0.5 + COLLISION_PAD, otherHalfH = oh*0.5 + COLLISION_PAD;
        const dx = this.x - other.x, dy = this.y - other.y;
        const overlapX = (halfW + otherHalfW) - Math.abs(dx);
        const overlapY = (halfH + otherHalfH) - Math.abs(dy);
        if(overlapX > 0 && overlapY > 0){
          if(overlapX < overlapY){ 
            const dirX = Math.sign(dx) || (Math.random()<0.5 ? 1 : -1); 
            this.vx += dirX * overlapX * PUSH_STRENGTH; 
          }
          else { 
            const dirY = Math.sign(dy) || (Math.random()<0.5 ? 1 : -1); 
            this.vy += dirY * overlapY * PUSH_STRENGTH; 
          }
        }
      }
      this.vx *= FRICTION; 
      this.vy *= FRICTION;
    }
    draw(now){
      if(!videoReady) return;
      const vW=boatVideo.videoWidth||640, vH=boatVideo.videoHeight||360;
      const srcW=vW*CROP.w, srcH=vH*CROP.h, srcX=vW*CROP.x, srcY=vH*CROP.y;

      // PERSPECTIVE: scale & opacity by vertical position
      const yNorm = Math.max(0, Math.min(1, (this.y || this.yBase) / H));
      const scale = PERSPECTIVE_MIN_SCALE + (PERSPECTIVE_MAX_SCALE - PERSPECTIVE_MIN_SCALE) * yNorm;

      // Bottom 50% = full opacity; top 50% fades
      let a;
      if (yNorm >= 0.5) {
        a = 1;
      } else {
        const t = yNorm / 0.5;
        a = OPACITY_MIN + (1 - OPACITY_MIN) * t;
      }
      if(this.morphingOut) a = 0;
      if(a <= 0) return;

      const displayH = BOAT_HEIGHT * scale;
      const displayW = displayH * (srcW/srcH);
      this._w=displayW; this._h=displayH;

      ctx.save();
      ctx.translate(this.x, this.y);

      if(this.highlightUntil){
        const remaining = this.highlightUntil - performance.now();
        if(remaining > 0){
          const duration = 6000;
          const tFrac = Math.max(0, remaining/duration);
          const fade = 1 - (1 - tFrac) * (1 - tFrac);
          ctx.save();
          ctx.globalAlpha = fade;
          const g = ctx.createRadialGradient(0,0,10, 0,0,220);
          g.addColorStop(0,'rgba(255,240,160,.35)');
          g.addColorStop(0.35,'rgba(255,210,100,.18)');
          g.addColorStop(1,'rgba(255,210,100,0)');
          ctx.globalCompositeOperation='screen';
          ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,220,0,Math.PI*2); ctx.fill();
          ctx.restore();
        } else {
          this.highlightUntil = 0;
        }
      }

      // FIXED: iOS-compatible blend mode rendering
      ctx.globalAlpha = a;

      const supportsFilter = typeof ctx.filter !== 'undefined';
      const prevFilter = supportsFilter ? ctx.filter : null;
      if (supportsFilter) {
        ctx.filter = this.variant === 'cheer' ? 'hue-rotate(68deg)' : 'none';
      }

      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                    (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

      if(isIOS) {
        const dpr = window.devicePixelRatio || 1;
        const offCanvas = document.createElement('canvas');
        offCanvas.width = displayW * dpr;
        offCanvas.height = displayH * dpr;
        const offCtx = offCanvas.getContext('2d');
        offCtx.scale(dpr, dpr);
        offCtx.drawImage(boatVideo, srcX, srcY, srcW, srcH, 0, 0, displayW, displayH);
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(offCanvas, -displayW/2, -displayH/2, displayW, displayH);
        ctx.globalCompositeOperation = 'source-over';
      } else {
        const prev = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = 'screen';
        ctx.drawImage(boatVideo, srcX,srcY,srcW,srcH, -displayW/2, -displayH/2, displayW, displayH);
        ctx.globalCompositeOperation = prev;
      }

      if (supportsFilter) {
        ctx.filter = prevFilter;
      }

      ctx.restore();
    }
    hit(mx,my){ 
      return mx>=this.x-this._w/2 && mx<=this.x+this._w/2 && 
             my>=this.y-this._h/2 && mx!=null && my!=null && 
             my>=this.y-this._h/2 && my<=this.y+this._h/2; 
    }
  }

  // Will be filled after Supabase fetch
  let boats = [];

  // Also add a periodic refresh every 5 minutes
  setInterval(refreshDoubtPool, 5 * 60 * 1000);

  /* ===== Unfolding NOTE factory (boat + composer) ===== */
  let overlay=null, noteEl=null, noteBoat=null, noteClosing=false, composerOpen=false;

  const NO_DRAG_SELECTOR = 'textarea, input, select, button, a, [contenteditable="true"], .compose-field, .pill-btn, .note-close';

  function makeDraggable(el, size){
    let dragging=false, startX=0, startY=0, startLeft=0, startTop=0;
    const clamp=(v,min,max)=>Math.max(min, Math.min(max, v));

    el.addEventListener('pointerdown', (e)=>{
      if(e.button && e.button !== 0) return;
      if (e.target.closest(NO_DRAG_SELECTOR)) return;
      dragging = true;
      el.classList.add('dragging');
      el.setPointerCapture(e.pointerId);
      startX = e.clientX; startY = e.clientY;
      startLeft = parseFloat(el.style.left)||0;
      startTop  = parseFloat(el.style.top)||0;
      e.preventDefault();
    });

    el.addEventListener('pointermove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - startX, dy = e.clientY - startY;
      let nextLeft = startLeft + dx, nextTop  = startTop  + dy;
      const maxL = innerWidth  - size, maxT = innerHeight - size;
      nextLeft = clamp(nextLeft, 0, Math.max(0, maxL));
      nextTop  = clamp(nextTop , 0, Math.max(0, maxT));
      el.style.left = nextLeft + 'px';
      el.style.top  = nextTop  + 'px';
    });

    const endDrag=(e)=>{
      if(!dragging) return;
      dragging = false;
      el.classList.remove('dragging');
      try{ el.releasePointerCapture(e.pointerId); }catch(_){}
    };
    el.addEventListener('pointerup', endDrag);
    el.addEventListener('pointercancel', endDrag);
    el.addEventListener('lostpointercapture', ()=>{ dragging=false; el.classList.remove('dragging'); });
  }

  function createNote({ x = null, y = null, title, bodyHTML, metaHTML, boat = null, startScale = 0.72 }) {
    overlay = document.createElement('div');
    overlay.className = 'note-overlay';
    overlay.innerHTML = `<div class="overlay-close" aria-hidden="true"></div>`;
    document.body.appendChild(overlay);

    noteEl = document.createElement('div');
    noteEl.className = 'note';

    // Responsive size
    const maxSize = Math.min(350, window.innerWidth * 0.9);
    const size = maxSize;
    const posX = (x ?? innerWidth / 2) - size / 2;
    const posY = (y ?? innerHeight / 2) - size / 2;

    noteEl.style.left = `${posX}px`;
    noteEl.style.top = `${posY}px`;
    noteEl.style.width = `${size}px`;
    noteEl.style.height = `${size}px`;
    noteEl.style.transformOrigin = 'center center';
    noteEl.style.transform = `scale(${startScale}) translateZ(0)`;

    const stage = document.createElement('div'); stage.className = 'note-stage';
    const frame = document.createElement('div'); frame.className = 'note-frame';
    noteEl.append(stage, frame);

    function makeBox(circleClass){
      const b = document.createElement('div'); b.className = 'note-box';
      const i = document.createElement('div'); i.className = 'note-in ' + circleClass;
      b.appendChild(i);
      return b;
    }
    stage.append(makeBox('one'), makeBox('two'), makeBox('thr'), makeBox('fou'));

    const content = document.createElement('div'); content.className='note-content';
    content.innerHTML = `
      <div class="note-title">${title}</div>
      ${bodyHTML}
      ${metaHTML||''}
    `;
    noteEl.appendChild(content);

    const closeBtn = document.createElement('button');
    closeBtn.className = 'note-close';
    closeBtn.setAttribute('aria-label','Close note');
    closeBtn.innerHTML = '&times;';
    closeBtn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });
    closeBtn.addEventListener('click', (e)=>{ e.stopPropagation(); closeNote(); });
    closeBtn.addEventListener('transitionend', (e)=>{
      if(e.propertyName === 'opacity' && getComputedStyle(closeBtn).opacity === '1'){
        closeBtn.style.pointerEvents = 'auto';
      }
    });
    noteEl.appendChild(closeBtn);

    overlay.appendChild(noteEl);
    noteBoat = boat || null;

    makeDraggable(noteEl, size);

    requestAnimationFrame(()=>{
      noteEl.style.transform = 'scale(1) translateZ(0)';
      setTimeout(()=> noteEl.classList.add('unfold'), 140);
    });

    overlay.querySelector('.overlay-close').addEventListener('click', closeNote, {once:true});
  }

  function closeNote(){
    if(!noteEl || noteClosing) return;
    noteClosing = true;

    if(noteBoat){
      noteBoat.morphingIn = false;
      // Don't set morphingOut - let the boat continue floating
    }

    noteEl.classList.add('closing');

    const FINISH = ()=> {
      overlay?.remove(); overlay=null; noteEl=null;
      noteBoat = null; noteClosing = false; composerOpen = false;
    };

    let done=false;
    noteEl.addEventListener('transitionend', (e)=>{
      if(done || e.propertyName !== 'opacity') return;
      done=true; FINISH();
    }, {once:true});
    setTimeout(()=>{ if(!done) FINISH(); }, 280);
  }

  function openNoteFromBoat(boat){
    boat.morphingIn = true;
    boat.morphT0 = performance.now();
    const entry = boat.entry || {};
    const variant = boat.variant || entry.type || 'doubt';

    const metaParts = [];
    if (entry.date) {
      const parsed = new Date(entry.date + 'T00:00:00');
      if (!Number.isNaN(parsed.getTime())) {
        metaParts.push(parsed.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' }));
      }
    }
    if (variant === 'cheer' && entry.attribution) {
      metaParts.push(entry.attribution);
    }

    const meta = metaParts.length ? `<div class="note-meta">${escapeHtml(metaParts.join(' • '))}</div>` : '';
    const body = `<div class="note-text">${escapeHtml(entry.text || '').replace(/\n/g, '<br>')}</div>`;

    const noteTitle = variant === 'cheer' ? 'Community Care' : 'Anonymous Doubt';
    const maxSize = Math.min(350, window.innerWidth * 0.9);

    // Center notes on mobile devices (640px and below)
    const isMobile = window.innerWidth <= 640;
    const noteX = isMobile ? innerWidth / 2 : boat.x;
    const noteY = isMobile ? innerHeight / 2 : boat.y;

    createNote({ x:noteX, y:noteY, title:noteTitle, bodyHTML:body, metaHTML:meta, boat, startScale:(boat._h/maxSize)*0.9 });
  }

  /* CTA → composer note */
  function openComposerNote() {
    composerOpen = true;

    const isCheersView = currentView === 'affirmations';
    const noteTitle = isCheersView ? 'Release a care note' : 'Release your doubt';
    const placeholderText = isCheersView ? 'Type your care note (200 characters max)' : 'Type your doubt (200 characters max)';

    const body = `
      <textarea class="compose-field" id="releaseInput" maxlength="200" placeholder="${placeholderText}"></textarea>
      <div class="compose-foot">
        <div><span id="charCount">0</span>/200</div>
        <button class="pill-btn" id="submitDoubt" type="button">Release</button>
      </div>
      <p class="compose-disclaimer">If you’re struggling with self-harm, please reach out for help at findahelpline.com. Offensive content will be removed.</p>
    `;

    createNote({
      x: innerWidth / 2,
      y: innerHeight / 2,
      title: noteTitle,
      bodyHTML: body,
      metaHTML: '',
      boat: null,
      startScale: 0.72
    });

    const input = document.getElementById('releaseInput');
    const count = document.getElementById('charCount');
    const submit = document.getElementById('submitDoubt');

    input.addEventListener('input', () => {
      count.textContent = input.value.length;
    });
    setTimeout(() => input.focus(), 50);

    async function doRelease() {
      const text = (input.value || '').trim();
      if (!text) {
        input.focus();
        return;
      }

      submit.disabled = true;
      const prev = submit.textContent;
      submit.textContent = 'Releasing…';
      const variant = getCurrentVariant();

      try {
        const { id, created_at, doubt } = await postDoubtToN8N(text);
        const b = new Boat(variant);
        b.entry = {
          text: doubt,
          date: (created_at || new Date().toISOString()).slice(0, 10),
          id,
          type: variant
        };
        if (variant === 'cheer') {
          const careEntry = {
            ...b.entry,
            attribution: b.entry.attribution || 'Shared from the drift',
            active: true
          };
          b.entry = careEntry;
          setSupportNotes([...SUPPORT_NOTES, careEntry]);
        }
        b.x = innerWidth / 2;
        b.yBase = innerHeight / 2;
        b.phase = 0;
        b.highlightUntil = performance.now() + 6000;
        boats.push(b);
        closeNote();
      } catch (err) {
        console.error('Release failed:', err);
        const friendlyType = variant === 'cheer' ? 'care note' : 'doubt';
        alert(err.message || `Failed to release your ${friendlyType}.`);
      } finally {
        submit.disabled = false;
        submit.textContent = prev;
      }
    }

    submit.addEventListener('click', doRelease);
    input.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault();
        doRelease();
      }
    });
  }

  /* Loop */
  function animate(now=0){ 
    ctx.clearRect(0,0,W,H); 

    // Update all first
    for(const b of boats){ 
      b.update(now, boats); 
    }

    // Draw sorted by y for proper layering (back-to-front)
    const byDepth = [...boats].sort((a,b)=> (a.y||a.yBase) - (b.y||b.yBase));
    for(const b of byDepth){
      b.draw(now);
    }

    requestAnimationFrame(animate); 
  }
  
  // Start animation immediately, don't wait for intro
  animate();

  /* Interactions */
  // Handle hover cursor
  canvas.addEventListener('pointermove', e=>{
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    let overBoat = false;
    
    for(const b of boats){ 
      if(b.hit(mx,my) && !b.morphingOut){
        overBoat = true;
        break;
      }
    }
    
    canvas.style.cursor = overBoat ? 'pointer' : 'default';
  });
  
  canvas.addEventListener('click', e=>{
    if(composerOpen) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    for(const b of boats){ 
      if(b.hit(mx,my)){ 
        if(b.morphingOut) return; 
        openNoteFromBoat(b); 
        break; 
      } 
    }
  });
  releaseBtn.addEventListener('click', openComposerNote);
  addEventListener('keydown', e=>{ if(e.key==='Escape'){ closeNote(); } });

 /* =========
     Boot flow
     ========= */
  (async function init(){
    const supportPromise = ensureSupportData(400);
    try{
      APPROVED_DOUBTS = await fetchApprovedDoubts(600);
      if (APPROVED_DOUBTS.length === 0) {
        console.warn('No approved doubts found; using placeholder.');
        APPROVED_DOUBTS = [{ id:'p1', text:'(waiting for first approved doubt…)', date:new Date().toISOString().slice(0,10) }];
      }

      // Initialize the shuffled pool after loading doubts
      initializeDoubtPool();

    } catch(err){
      console.error(err);
      // Soft fallback if Supabase is unreachable
      APPROVED_DOUBTS = [{ id:'p1', text:'(temporarily unable to load doubts)', date:new Date().toISOString().slice(0,10) }];
      initializeDoubtPool();
    } finally {
      await supportPromise.catch(() => {});
      // Seed boats only after we have something to show
      boats = Array.from({length: BOAT_COUNT}, () => new Boat(getCurrentVariant()));
    }

// Update counter on load
fetchTotalDoubts().then(count => {
  if (!doubtCounter) return;
  doubtCounter.style.visibility = 'visible';
  if (count > 0) {
    animateDoubtCounter(doubtCounter, count);
  } else {
    doubtCounter.textContent = '0 boats released';
  }
}).catch(() => {
  if (doubtCounter) doubtCounter.style.visibility = 'hidden';
});
})();
</script>



<script>
(() => {
  const header = document.querySelector('header.ripple');
  if (!header) return;

  const frames = [
    { opacity: 1, transform: 'translate3d(0,0,0) scale(1)', textShadow: '0 0 0 #fff' },
    { offset: 0.4, opacity: 0.35 },
    { offset: 0.5, opacity: 1, transform: 'translate3d(0.5em,0,0) scale(1.1)', textShadow: '0 0 20px #fff' },
    { offset: 0.75, opacity: 1, transform: 'translate3d(0,0,0) scale(1)', textShadow: '0 0 0 #fff' }
  ];

  const letters = [...header.children];
  const anims = letters.map((el, i) => {
    const a = el.animate(frames, {
      duration: 4000,
      fill: 'both',
      delay: i * 60 // optional stagger
    });
    a.pause();
    return a;
  });

  header.addEventListener('mouseenter', () => {
    anims.forEach(a => { a.playbackRate = 1; a.play(); });
  });

  header.addEventListener('mouseleave', () => {
    anims.forEach(a => a.reverse());
  });
})();
</script>

</body></html>
